<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CSV Accounts, Categories & Movements Viewer</title>
    <style>
      body {
        font-family: "Inter", "Segoe UI", Arial, sans-serif;
        margin: 0;
        background: #15131b;
        color: #c9c6d1;
      }
      .page {
        max-width: 1100px;
        margin: 32px auto;
        padding: 24px 28px;
        background: #1f1c27;
        border-radius: 12px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      }
      h1 {
        margin-bottom: 8px;
        font-size: 24px;
        color: #d7d2e3;
      }
      .note {
        color: #9a96a8;
        font-size: 13px;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        margin-bottom: 16px;
      }
      .controls input[type="file"] {
        padding: 6px;
        background: #211f2b;
        border: 1px solid #3a3646;
        border-radius: 8px;
        color: #c9c6d1;
      }
      .controls input[type="file"]::file-selector-button {
        border: 1px solid #4a4458;
        background: #2a2635;
        color: #c9c6d1;
        padding: 6px 10px;
        border-radius: 6px;
        margin-right: 10px;
        cursor: pointer;
      }
      .controls input[type="file"]::file-selector-button:hover {
        background: #342f43;
        border-color: #5b546b;
      }
      .controls input[type="text"] {
        width: 60px;
        padding: 6px 8px;
        border: 1px solid #3a3646;
        border-radius: 8px;
        background: #211f2b;
        color: #c9c6d1;
      }
      select {
        width: 100%;
        padding: 6px 10px;
        border: 1px solid #3a3646;
        border-radius: 8px;
        background: #211f2b;
        color: #c9c6d1;
        font-size: 13px;
        appearance: none;
        background-image:
          linear-gradient(45deg, transparent 50%, #9a96a8 50%),
          linear-gradient(135deg, #9a96a8 50%, transparent 50%),
          linear-gradient(to right, #2b2636, #2b2636);
        background-position:
          calc(100% - 16px) 50%,
          calc(100% - 11px) 50%,
          100% 0;
        background-size: 5px 5px, 5px 5px, 2.5em 100%;
        background-repeat: no-repeat;
      }
      select:focus {
        outline: none;
        border-color: #5b546b;
        box-shadow: 0 0 0 2px rgba(139, 134, 163, 0.25);
      }
      button {
        border: 1px solid #4a4458;
        background: #2b2636;
        color: #c9c6d1;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
      }
      button:hover {
        background: #352f45;
        border-color: #5b546b;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 12px;
        background: #1a1823;
      }
      th,
      td {
        border: 1px solid #332f3d;
        padding: 6px 8px;
        text-align: left;
        font-size: 14px;
      }
      th {
        background: #262233;
        color: #cfd9ff;
      }
      .value-positive {
        color: #7cd39b;
      }
      .value-negative {
        color: #f08aa1;
      }
      .error {
        color: #e8a7c5;
        margin-top: 8px;
      }
      .panel {
        margin-top: 20px;
      }
      .panel textarea {
        width: 100%;
        min-height: 160px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 12px;
        padding: 10px;
        border: 1px solid #3a3646;
        border-radius: 8px;
        background: #211f2b;
        color: #c9c6d1;
        box-sizing: border-box;
      }
      .add-row {
        margin-top: 8px;
      }
      .add-row button {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        font-size: 18px;
        line-height: 1;
      }
      .tabs {
        display: flex;
        gap: 8px;
        margin: 16px 0 20px;
      }
      .tab-button {
        border: 1px solid #4a4458;
        background: #2a2635;
        color: #c9c6d1;
        padding: 8px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
      }
      .tab-button.active {
        background: #342f43;
        border-color: #5b546b;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="page">
      <h1>CSV Accounts, Categories & Movements Viewer</h1>
      <p class="note">
        Load CSV files and view parsed data. Accounts get incremental IDs.
      </p>

      <div class="tabs">
        <button type="button" class="tab-button active" data-tab="accounts">
          Accounts
        </button>
        <button type="button" class="tab-button" data-tab="categories">
          Categories
        </button>
        <button type="button" class="tab-button" data-tab="periodicities">
          Periodicities
        </button>
        <button type="button" class="tab-button" data-tab="movements">
          Movements
        </button>
      </div>

      <section id="tab-accounts" class="tab-content active">
        <div class="controls">
          <input type="file" id="csvFile-accounts" accept=".csv,text/csv" />
          <label for="delimiter-accounts">Delimiter:</label>
          <input type="text" id="delimiter-accounts" value="," maxlength="1" />
          <button type="button" id="parseBtn-accounts">Parse CSV</button>
          <button type="button" id="sqlBtn-accounts">Generate SQL</button>
          <button type="button" id="csvBtn-accounts">Show CSV</button>
          <button type="button" id="clearBtn-accounts">Clear</button>
        </div>

        <div id="error-accounts" class="error"></div>
        <div id="tableContainer-accounts"></div>
        <div id="addRowContainer-accounts"></div>
        <div class="panel">
          <h2>Output</h2>
          <textarea id="sqlOutput-accounts" readonly></textarea>
        </div>
      </section>

      <section id="tab-movements" class="tab-content">
        <div class="controls">
          <input type="file" id="csvFile-movements" accept=".csv,text/csv" />
          <label for="delimiter-movements">Delimiter:</label>
          <input type="text" id="delimiter-movements" value="," maxlength="1" />
          <button type="button" id="parseBtn-movements">Parse CSV</button>
          <button type="button" id="sqlBtn-movements">Generate SQL</button>
          <button type="button" id="csvBtn-movements">Show CSV</button>
          <button type="button" id="clearBtn-movements">Clear</button>
        </div>

        <div id="error-movements" class="error"></div>
        <div id="tableContainer-movements"></div>
        <div id="addRowContainer-movements"></div>
        <div class="panel">
          <h2>Output</h2>
          <textarea id="sqlOutput-movements" readonly></textarea>
        </div>
      </section>

      <section id="tab-categories" class="tab-content">
        <div class="controls">
          <input type="file" id="csvFile-categories" accept=".csv,text/csv" />
          <label for="delimiter-categories">Delimiter:</label>
          <input type="text" id="delimiter-categories" value="," maxlength="1" />
          <button type="button" id="parseBtn-categories">Parse CSV</button>
          <button type="button" id="sqlBtn-categories">Generate SQL</button>
          <button type="button" id="csvBtn-categories">Show CSV</button>
          <button type="button" id="clearBtn-categories">Clear</button>
        </div>

        <div id="error-categories" class="error"></div>
        <div id="tableContainer-categories"></div>
        <div id="addRowContainer-categories"></div>
        <div class="panel">
          <h2>Output</h2>
          <textarea id="sqlOutput-categories" readonly></textarea>
        </div>
      </section>

      <section id="tab-periodicities" class="tab-content">
        <div class="controls">
          <input type="file" id="csvFile-periodicities" accept=".csv,text/csv" />
          <label for="delimiter-periodicities">Delimiter:</label>
          <input type="text" id="delimiter-periodicities" value="," maxlength="1" />
          <button type="button" id="parseBtn-periodicities">Parse CSV</button>
          <button type="button" id="sqlBtn-periodicities">Generate SQL</button>
          <button type="button" id="csvBtn-periodicities">Show CSV</button>
          <button type="button" id="clearBtn-periodicities">Clear</button>
        </div>

        <div id="error-periodicities" class="error"></div>
        <div id="tableContainer-periodicities"></div>
        <div id="addRowContainer-periodicities"></div>
        <div class="panel">
          <h2>Output</h2>
          <textarea id="sqlOutput-periodicities" readonly></textarea>
        </div>
      </section>
    </div>

    <script>
      const state = {
        accounts: {
          headers: [],
          rows: [],
          idToName: new Map(),
        },
        categories: {
          headers: [],
          rows: [],
          idToName: new Map(),
        },
        periodicities: {
          headers: [],
          rows: [],
          idToName: new Map(),
        },
        movements: {
          headers: [],
          rows: [],
        },
      };

      const tabButtons = document.querySelectorAll(".tab-button");
      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          tabButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          const target = button.dataset.tab;
          document.querySelectorAll(".tab-content").forEach((section) => {
            section.classList.toggle(
              "active",
              section.id === `tab-${target}`
            );
          });
        });
      });

      function parseCSV(text, delimiter) {
        const rows = [];
        let row = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          const next = text[i + 1];

          if (char === "\"") {
            if (inQuotes && next === "\"") {
              current += "\"";
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
            continue;
          }

          if (char === "\n" || char === "\r") {
            if (char === "\r" && next === "\n") {
              i += 1;
            }
            if (inQuotes) {
              current += "\n";
              continue;
            }
            row.push(current);
            if (row.some((cell) => cell.trim() !== "")) {
              rows.push(row);
            }
            row = [];
            current = "";
            continue;
          }

          if (char === delimiter && !inQuotes) {
            row.push(current);
            current = "";
            continue;
          }

          current += char;
        }
        if (current.length > 0 || row.length > 0) {
          row.push(current);
          if (row.some((cell) => cell.trim() !== "")) {
            rows.push(row);
          }
        }
        return rows;
      }

      function normalizeHeader(header) {
        return header
          .replace(/^\uFEFF/, "")
          .trim()
          .toLowerCase()
          .replace(/[\s-]+/g, "_");
      }

      function applyMovementOrder(rows) {
        if (rows.length === 0) {
          return rows;
        }
        const headers = rows[0];
        const normalized = headers.map(normalizeHeader);
        const dateIndex = normalized.indexOf("date");
        const accountIndex = normalized.indexOf("account_id");
        if (dateIndex === -1 || accountIndex === -1 || dateIndex < accountIndex) {
          return rows;
        }
        const reorderedHeaders = headers.slice();
        reorderedHeaders[dateIndex] = headers[accountIndex];
        reorderedHeaders[accountIndex] = headers[dateIndex];
        const reorderedRows = rows.slice(1).map((row) => {
          const nextRow = row.slice();
          nextRow[dateIndex] = row[accountIndex];
          nextRow[accountIndex] = row[dateIndex];
          return nextRow;
        });
        return [reorderedHeaders, ...reorderedRows];
      }

      function renderTable(
        rows,
        container,
        valueTransform,
        headerOrder,
        onCellEdit,
        selectProvider
      ) {
        if (rows.length === 0) {
          container.innerHTML = "<p>No rows to display.</p>";
          return;
        }
        const rawHeaders = rows[0];
        const displayHeaders = headerOrder || rawHeaders;
        const dataRows = rows.slice(1);

        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        displayHeaders.forEach((header) => {
          const th = document.createElement("th");
          th.textContent = header;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        dataRows.forEach((row, rowIndex) => {
          const tr = document.createElement("tr");
          displayHeaders.forEach((header) => {
            const idx = rawHeaders.indexOf(header);
            const td = document.createElement("td");
            const rawValue = row[idx] || "";
            const displayValue = valueTransform
              ? valueTransform(header, rawValue)
              : rawValue;
            const options = selectProvider ? selectProvider(header) : null;
            if (options && options.length > 0) {
              const select = document.createElement("select");
              options.forEach((option) => {
                const opt = document.createElement("option");
                opt.value = option.value;
                opt.textContent = option.label;
                select.appendChild(opt);
              });
              const currentValue = rawValue.trim();
              if (currentValue !== "" && !options.some((o) => o.value === currentValue)) {
                const opt = document.createElement("option");
                opt.value = currentValue;
                opt.textContent = currentValue;
                select.appendChild(opt);
              }
              select.value = currentValue || options[0].value;
              select.addEventListener("change", () => {
                onCellEdit?.(rowIndex, idx, select.value);
              });
              td.appendChild(select);
            } else {
              td.textContent = displayValue;
              const normalizedHeader = normalizeHeader(header);
              if (normalizedHeader === "value") {
                const trimmedValue = rawValue.trim();
                if (trimmedValue !== "" && isNumericValue(trimmedValue)) {
                  td.classList.toggle("value-negative", Number(trimmedValue) < 0);
                  td.classList.toggle("value-positive", Number(trimmedValue) >= 0);
                }
              }
              if (onCellEdit && isEditableText(header, rawValue)) {
                td.contentEditable = "true";
                td.addEventListener("keydown", (event) => {
                  if (event.key === "Enter") {
                    event.preventDefault();
                    td.blur();
                  }
                });
                td.addEventListener("blur", () => {
                  const nextValue = td.textContent ?? "";
                  onCellEdit(rowIndex, idx, nextValue);
                  if (normalizedHeader === "value") {
                    const trimmedValue = nextValue.trim();
                    td.classList.remove("value-negative", "value-positive");
                    if (trimmedValue !== "" && isNumericValue(trimmedValue)) {
                      td.classList.toggle("value-negative", Number(trimmedValue) < 0);
                      td.classList.toggle("value-positive", Number(trimmedValue) >= 0);
                    }
                  }
                });
              }
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        container.innerHTML = "";
        container.appendChild(table);
      }

      function renderAddRowButton(containerId, onAdd) {
        const container = document.getElementById(containerId);
        if (!container) {
          return;
        }
        container.innerHTML = "";
        const wrapper = document.createElement("div");
        wrapper.className = "add-row";
        const button = document.createElement("button");
        button.type = "button";
        button.textContent = "+";
        button.title = "Add row";
        button.addEventListener("click", onAdd);
        wrapper.appendChild(button);
        container.appendChild(wrapper);
      }

      function escapeCsvCell(value, delimiter, forceQuotes) {
        const needsQuotes =
          forceQuotes ||
          value.includes('"') ||
          value.includes("\n") ||
          value.includes("\r") ||
          value.includes(delimiter);
        if (!needsQuotes) {
          return value;
        }
        return `"${value.replace(/"/g, '""')}"`;
      }

      function isNumericValue(value) {
        return /^[-+]?\d+(\.\d+)?$/.test(value);
      }

      function isDateValue(value) {
        return (
          /^\d{4}-\d{2}-\d{2}$/.test(value) ||
          /^\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}(:\d{2})?$/.test(value)
        );
      }

      function isEditableText(header, value) {
        const normalizedHeader = normalizeHeader(header);
        if (
          normalizedHeader === "id" ||
          normalizedHeader === "account_id" ||
          normalizedHeader === "category" ||
          normalizedHeader === "category_id" ||
          normalizedHeader === "periodicity" ||
          normalizedHeader === "periodicity_id"
        ) {
          return true;
        }
        return true;
      }

      function buildCsvText(headers, rows, delimiter) {
        const headerLine = headers
          .map((header) => escapeCsvCell(String(header), delimiter, false))
          .join(delimiter);
        const rowLines = rows.map((row) =>
          row
            .map((cell) => {
              const text = String(cell ?? "");
              const trimmed = text.trim();
              const forceQuotes =
                trimmed === "" ? true : !(isNumericValue(trimmed) || isDateValue(trimmed));
              return escapeCsvCell(text, delimiter, forceQuotes);
            })
            .join(delimiter)
        );
        return [headerLine, ...rowLines].join("\n");
      }

      function escapeSqlString(value) {
        return value.replace(/'/g, "''");
      }

      function toSqlValue(value) {
        const trimmed = value.trim();
        if (trimmed === "") {
          return "NULL";
        }
        if (/^[-+]?\d+(\.\d+)?$/.test(trimmed)) {
          return trimmed;
        }
        return `'${escapeSqlString(trimmed)}'`;
      }

      function generateAccountsSql(headers, rows) {
        const normalizedHeaders = headers.map(normalizeHeader);
        const nameIndex = normalizedHeaders.indexOf("name");
        const typeIndex = normalizedHeaders.indexOf("account_type");
        const ibanIndex = normalizedHeaders.indexOf("iban");
        const closedIndex = normalizedHeaders.indexOf("closed");
        const commentsIndex = normalizedHeaders.indexOf("comments");

        if (nameIndex === -1 || typeIndex === -1 || ibanIndex === -1) {
          return {
            sql: "",
            error: "Accounts CSV must include name, account_type, and iban.",
          };
        }

        const lines = rows.map((row) => {
          const name = toSqlValue(row[nameIndex] || "");
          const accountType = toSqlValue(row[typeIndex] || "");
          const iban = toSqlValue(row[ibanIndex] || "");
          const closed = closedIndex !== -1 ? toSqlValue(row[closedIndex] || "") : "NULL";
          const comments =
            commentsIndex !== -1 ? toSqlValue(row[commentsIndex] || "") : "NULL";
          return `INSERT INTO accounts (name, account_type, iban, closed, comments) VALUES (${name}, ${accountType}, ${iban}, ${closed}, ${comments});`;
        });
        return { sql: lines.join("\n"), error: "" };
      }

      function generateMovementsSql(headers, rows) {
        const normalizedHeaders = headers.map(normalizeHeader);
        const accountIndex = normalizedHeaders.indexOf("account_id");
        const dateIndex = normalizedHeaders.indexOf("date");
        const categoryIndex = normalizedHeaders.indexOf("category");
        const periodicityIndex = normalizedHeaders.indexOf("periodicity");
        const descriptionIndex = normalizedHeaders.indexOf("description");
        const valueIndex = normalizedHeaders.indexOf("value");
        const notesIndex = normalizedHeaders.indexOf("notes");

        if (
          accountIndex === -1 ||
          dateIndex === -1 ||
          categoryIndex === -1 ||
          descriptionIndex === -1 ||
          valueIndex === -1
        ) {
          return {
            sql: "",
            error:
              "Movements CSV must include account_id, date, category, description, and value.",
          };
        }

        const lines = rows.map((row) => {
          const accountId = toSqlValue(row[accountIndex] || "");
          const dateValue = toSqlValue(row[dateIndex] || "");
          const category = toSqlValue(row[categoryIndex] || "");
          const periodicity =
            periodicityIndex !== -1 ? toSqlValue(row[periodicityIndex] || "") : "NULL";
          const description = toSqlValue(row[descriptionIndex] || "");
          const value = toSqlValue(row[valueIndex] || "");
          const notes = notesIndex !== -1 ? toSqlValue(row[notesIndex] || "") : "NULL";
          return `INSERT INTO bank_movements (date, account_id, category, periodicity, description, value, notes) VALUES (${dateValue}, ${accountId}, ${category}, ${periodicity}, ${description}, ${value}, ${notes});`;
        });
        return { sql: lines.join("\n"), error: "" };
      }

      function generateCategoriesSql(headers, rows) {
        const normalizedHeaders = headers.map(normalizeHeader);
        const nameIndex = normalizedHeaders.indexOf("name");
        const descriptionIndex = normalizedHeaders.indexOf("description");

        if (nameIndex === -1) {
          return {
            sql: "",
            error: "Categories CSV must include name.",
          };
        }

        const lines = rows.map((row) => {
          const name = toSqlValue(row[nameIndex] || "");
          const description =
            descriptionIndex !== -1 ? toSqlValue(row[descriptionIndex] || "") : "NULL";
          return `INSERT INTO data_mov_categories (name, description) VALUES (${name}, ${description});`;
        });
        return { sql: lines.join("\n"), error: "" };
      }

      function generatePeriodicitiesSql(headers, rows) {
        const normalizedHeaders = headers.map(normalizeHeader);
        const nameIndex = normalizedHeaders.indexOf("name");
        const descriptionIndex = normalizedHeaders.indexOf("description");

        if (nameIndex === -1) {
          return {
            sql: "",
            error: "Periodicities CSV must include name.",
          };
        }

        const lines = rows.map((row) => {
          const name = toSqlValue(row[nameIndex] || "");
          const description =
            descriptionIndex !== -1 ? toSqlValue(row[descriptionIndex] || "") : "NULL";
          return `INSERT INTO data_mov_periodicities (name, description) VALUES (${name}, ${description});`;
        });
        return { sql: lines.join("\n"), error: "" };
      }

      function reorderHeaders(headers, first, second) {
        const normalized = headers.map(normalizeHeader);
        const firstIndex = normalized.indexOf(first);
        const secondIndex = normalized.indexOf(second);
        if (firstIndex === -1 || secondIndex === -1) {
          return headers;
        }
        const reordered = headers.slice();
        const firstHeader = reordered[firstIndex];
        const secondHeader = reordered[secondIndex];
        reordered[firstIndex] = secondHeader;
        reordered[secondIndex] = firstHeader;
        return reordered;
      }

      function renderAccountsTable(rawRows) {
        const container = document.getElementById("tableContainer-accounts");
        if (rawRows.length === 0) {
          container.innerHTML = "<p>No rows to display.</p>";
          return;
        }
        const rawHeaders = rawRows[0];
        const dataRows = rawRows.slice(1);
        const normalizedHeaders = rawHeaders.map(normalizeHeader);
        const nameIndex = normalizedHeaders.indexOf("name");

        const displayHeaders = ["id"];
        rawHeaders.forEach((header) => {
          displayHeaders.push(header);
        });

        state.accounts.idToName.clear();
        dataRows.forEach((row, index) => {
          const idValue = String(index + 1);
          const nameValue = nameIndex !== -1 ? (row[nameIndex] || "").trim() : "";
          if (nameValue) {
            state.accounts.idToName.set(idValue, nameValue);
          }
        });

        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        displayHeaders.forEach((header) => {
          const th = document.createElement("th");
          th.textContent = header;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        dataRows.forEach((row, index) => {
          const tr = document.createElement("tr");
          const displayRow = [String(index + 1), ...row];
          displayHeaders.forEach((header, idx) => {
            const td = document.createElement("td");
            td.textContent = displayRow[idx] || "";
            if (idx > 0 && isEditableText(header, displayRow[idx] || "")) {
              td.contentEditable = "true";
              td.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                  event.preventDefault();
                  td.blur();
                }
              });
              td.addEventListener("blur", () => {
                const updated = td.textContent ?? "";
                const rowIndex = index;
                const rawIndex = idx - 1;
                state.accounts.rows[rowIndex][rawIndex] = updated;
                if (rawIndex === nameIndex) {
                  const idValue = String(rowIndex + 1);
                  if (updated.trim()) {
                    state.accounts.idToName.set(idValue, updated.trim());
                  } else {
                    state.accounts.idToName.delete(idValue);
                  }
                  refreshMovementsTable();
                }
              });
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        container.innerHTML = "";
        container.appendChild(table);
        renderAddRowButton("addRowContainer-accounts", () => {
          const emptyRow = rawHeaders.map(() => "");
          state.accounts.rows.push(emptyRow);
          renderAccountsTable([rawHeaders, ...state.accounts.rows]);
        });
      }

      function renderCategoriesTable(rawRows) {
        const container = document.getElementById("tableContainer-categories");
        if (rawRows.length === 0) {
          container.innerHTML = "<p>No rows to display.</p>";
          return;
        }
        const rawHeaders = rawRows[0];
        const dataRows = rawRows.slice(1);
        const normalizedHeaders = rawHeaders.map(normalizeHeader);
        const nameIndex = normalizedHeaders.indexOf("name");

        const displayHeaders = ["id"];
        rawHeaders.forEach((header) => {
          displayHeaders.push(header);
        });

        state.categories.idToName.clear();
        dataRows.forEach((row, index) => {
          const idValue = String(index + 1);
          const nameValue = nameIndex !== -1 ? (row[nameIndex] || "").trim() : "";
          if (nameValue) {
            state.categories.idToName.set(idValue, nameValue);
          }
        });

        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        displayHeaders.forEach((header) => {
          const th = document.createElement("th");
          th.textContent = header;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        dataRows.forEach((row, index) => {
          const tr = document.createElement("tr");
          const displayRow = [String(index + 1), ...row];
          displayHeaders.forEach((header, idx) => {
            const td = document.createElement("td");
            td.textContent = displayRow[idx] || "";
            if (idx > 0 && isEditableText(header, displayRow[idx] || "")) {
              td.contentEditable = "true";
              td.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                  event.preventDefault();
                  td.blur();
                }
              });
              td.addEventListener("blur", () => {
                const updated = td.textContent ?? "";
                const rowIndex = index;
                const rawIndex = idx - 1;
                state.categories.rows[rowIndex][rawIndex] = updated;
                if (rawIndex === nameIndex) {
                  const idValue = String(rowIndex + 1);
                  if (updated.trim()) {
                    state.categories.idToName.set(idValue, updated.trim());
                  } else {
                    state.categories.idToName.delete(idValue);
                  }
                  refreshMovementsTable();
                }
              });
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        container.innerHTML = "";
        container.appendChild(table);
        renderAddRowButton("addRowContainer-categories", () => {
          const emptyRow = rawHeaders.map(() => "");
          state.categories.rows.push(emptyRow);
          renderCategoriesTable([rawHeaders, ...state.categories.rows]);
        });
      }

      function renderPeriodicitiesTable(rawRows) {
        const container = document.getElementById("tableContainer-periodicities");
        if (rawRows.length === 0) {
          container.innerHTML = "<p>No rows to display.</p>";
          return;
        }
        const rawHeaders = rawRows[0];
        const dataRows = rawRows.slice(1);
        const normalizedHeaders = rawHeaders.map(normalizeHeader);
        const nameIndex = normalizedHeaders.indexOf("name");

        const displayHeaders = ["id"];
        rawHeaders.forEach((header) => {
          displayHeaders.push(header);
        });

        state.periodicities.idToName.clear();
        dataRows.forEach((row, index) => {
          const idValue = String(index + 1);
          const nameValue = nameIndex !== -1 ? (row[nameIndex] || "").trim() : "";
          if (nameValue) {
            state.periodicities.idToName.set(idValue, nameValue);
          }
        });

        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        displayHeaders.forEach((header) => {
          const th = document.createElement("th");
          th.textContent = header;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        dataRows.forEach((row, index) => {
          const tr = document.createElement("tr");
          const displayRow = [String(index + 1), ...row];
          displayHeaders.forEach((header, idx) => {
            const td = document.createElement("td");
            td.textContent = displayRow[idx] || "";
            if (idx > 0 && isEditableText(header, displayRow[idx] || "")) {
              td.contentEditable = "true";
              td.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                  event.preventDefault();
                  td.blur();
                }
              });
              td.addEventListener("blur", () => {
                const updated = td.textContent ?? "";
                const rowIndex = index;
                const rawIndex = idx - 1;
                state.periodicities.rows[rowIndex][rawIndex] = updated;
                if (rawIndex === nameIndex) {
                  const idValue = String(rowIndex + 1);
                  if (updated.trim()) {
                    state.periodicities.idToName.set(idValue, updated.trim());
                  } else {
                    state.periodicities.idToName.delete(idValue);
                  }
                  refreshMovementsTable();
                }
              });
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        container.innerHTML = "";
        container.appendChild(table);
        renderAddRowButton("addRowContainer-periodicities", () => {
          const emptyRow = rawHeaders.map(() => "");
          state.periodicities.rows.push(emptyRow);
          renderPeriodicitiesTable([rawHeaders, ...state.periodicities.rows]);
        });
      }

      function movementDisplayValue(header, rawValue) {
        const normalizedHeader = normalizeHeader(header);
        if (normalizedHeader === "account_id") {
          const key = rawValue.trim();
          if (state.accounts.idToName.has(key)) {
            return state.accounts.idToName.get(key);
          }
        }
        if (normalizedHeader === "category" || normalizedHeader === "category_id") {
          const key = rawValue.trim();
          if (state.categories.idToName.has(key)) {
            return state.categories.idToName.get(key);
          }
        }
        if (
          normalizedHeader === "periodicity" ||
          normalizedHeader === "periodicity_id"
        ) {
          const key = rawValue.trim();
          if (state.periodicities.idToName.has(key)) {
            return state.periodicities.idToName.get(key);
          }
        }
        return rawValue;
      }

      function getIdOptions(header) {
        const normalizedHeader = normalizeHeader(header);
        if (normalizedHeader === "account_id") {
          return Array.from(state.accounts.idToName.entries()).map(([value, label]) => ({
            value,
            label,
          }));
        }
        if (normalizedHeader === "category" || normalizedHeader === "category_id") {
          return Array.from(state.categories.idToName.entries()).map(
            ([value, label]) => ({
              value,
              label,
            })
          );
        }
        if (
          normalizedHeader === "periodicity" ||
          normalizedHeader === "periodicity_id"
        ) {
          return Array.from(state.periodicities.idToName.entries()).map(
            ([value, label]) => ({
              value,
              label,
            })
          );
        }
        return null;
      }

      function refreshMovementsTable() {
        if (state.movements.rows.length === 0) {
          return;
        }
        const displayHeaders = reorderHeaders(
          state.movements.headers,
          "date",
          "account_id"
        );
        renderTable(
          [state.movements.headers, ...state.movements.rows],
          document.getElementById("tableContainer-movements"),
          movementDisplayValue,
          displayHeaders,
          (rowIndex, colIndex, nextValue) => {
            state.movements.rows[rowIndex][colIndex] = nextValue;
          },
          getIdOptions
        );
        renderAddRowButton("addRowContainer-movements", () => {
          const emptyRow = state.movements.headers.map(() => "");
          state.movements.rows.push(emptyRow);
          refreshMovementsTable();
        });
      }

      function setupImporter(key) {
        const csvFileInput = document.getElementById(`csvFile-${key}`);
        const delimiterInput = document.getElementById(`delimiter-${key}`);
        const parseBtn = document.getElementById(`parseBtn-${key}`);
        const sqlBtn = document.getElementById(`sqlBtn-${key}`);
        const csvBtn = document.getElementById(`csvBtn-${key}`);
        const clearBtn = document.getElementById(`clearBtn-${key}`);
        const tableContainer = document.getElementById(`tableContainer-${key}`);
        const errorEl = document.getElementById(`error-${key}`);
        const sqlOutput = document.getElementById(`sqlOutput-${key}`);

        function setError(message) {
          errorEl.textContent = message || "";
        }

        function handleFile() {
          setError("");
          const file = csvFileInput.files[0];
          if (!file) {
            setError("Please select a CSV file.");
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            const delimiter = delimiterInput.value || ",";
            const rows = parseCSV(reader.result, delimiter);
            if (rows.length === 0) {
              setError("CSV is empty.");
              return;
            }
            if (key === "accounts") {
              state.accounts.headers = rows[0];
              state.accounts.rows = rows.slice(1);
              renderAccountsTable(rows);
              const movementState = state.movements;
              if (movementState.rows.length > 0) {
                refreshMovementsTable();
              }
              return;
            }
            if (key === "categories") {
              state.categories.headers = rows[0];
              state.categories.rows = rows.slice(1);
              renderCategoriesTable(rows);
              const movementState = state.movements;
              if (movementState.rows.length > 0) {
                refreshMovementsTable();
              }
              return;
            }
            if (key === "periodicities") {
              state.periodicities.headers = rows[0];
              state.periodicities.rows = rows.slice(1);
              renderPeriodicitiesTable(rows);
              const movementState = state.movements;
              if (movementState.rows.length > 0) {
                refreshMovementsTable();
              }
              return;
            }
            if (key === "movements") {
              const orderedRows = applyMovementOrder(rows);
              state.movements.headers = orderedRows[0];
              state.movements.rows = orderedRows.slice(1);
              const displayHeaders = reorderHeaders(
                state.movements.headers,
                "date",
                "account_id"
              );
              renderTable(
                orderedRows,
                tableContainer,
                movementDisplayValue,
                displayHeaders,
                (rowIndex, colIndex, nextValue) => {
                  state.movements.rows[rowIndex][colIndex] = nextValue;
                },
                getIdOptions
              );
              renderAddRowButton("addRowContainer-movements", () => {
                const emptyRow = state.movements.headers.map(() => "");
                state.movements.rows.push(emptyRow);
                refreshMovementsTable();
              });
              return;
            }
            renderTable(rows, tableContainer);
          };
          reader.onerror = () => setError("Unable to read CSV file.");
          reader.readAsText(file);
        }

        parseBtn.addEventListener("click", handleFile);
        csvFileInput.addEventListener("change", () => {
          if (csvFileInput.files && csvFileInput.files.length > 0) {
            handleFile();
          }
        });

        clearBtn.addEventListener("click", () => {
          csvFileInput.value = "";
          tableContainer.innerHTML = "";
          sqlOutput.value = "";
          setError("");
          if (key === "accounts") {
            state.accounts.headers = [];
            state.accounts.rows = [];
            state.accounts.idToName.clear();
            document.getElementById("addRowContainer-accounts").innerHTML = "";
            if (state.movements.rows.length > 0) {
              refreshMovementsTable();
            }
          }
          if (key === "categories") {
            state.categories.headers = [];
            state.categories.rows = [];
            state.categories.idToName.clear();
            document.getElementById("addRowContainer-categories").innerHTML = "";
            if (state.movements.rows.length > 0) {
              refreshMovementsTable();
            }
          }
          if (key === "periodicities") {
            state.periodicities.headers = [];
            state.periodicities.rows = [];
            state.periodicities.idToName.clear();
            document.getElementById("addRowContainer-periodicities").innerHTML = "";
            if (state.movements.rows.length > 0) {
              refreshMovementsTable();
            }
          }
          if (key === "movements") {
            state.movements.headers = [];
            state.movements.rows = [];
            document.getElementById("addRowContainer-movements").innerHTML = "";
          }
        });

        csvBtn.addEventListener("click", () => {
          setError("");
          const delimiter = delimiterInput.value || ",";
          if (key === "accounts") {
            if (state.accounts.rows.length === 0) {
              setError("No parsed accounts. Parse a CSV first.");
              return;
            }
            sqlOutput.value = buildCsvText(
              state.accounts.headers,
              state.accounts.rows,
              delimiter
            );
            return;
          }
          if (key === "categories") {
            if (state.categories.rows.length === 0) {
              setError("No parsed categories. Parse a CSV first.");
              return;
            }
            sqlOutput.value = buildCsvText(
              state.categories.headers,
              state.categories.rows,
              delimiter
            );
            return;
          }
          if (key === "periodicities") {
            if (state.periodicities.rows.length === 0) {
              setError("No parsed periodicities. Parse a CSV first.");
              return;
            }
            sqlOutput.value = buildCsvText(
              state.periodicities.headers,
              state.periodicities.rows,
              delimiter
            );
            return;
          }
          if (key === "movements") {
            if (state.movements.rows.length === 0) {
              setError("No parsed movements. Parse a CSV first.");
              return;
            }
            sqlOutput.value = buildCsvText(
              state.movements.headers,
              state.movements.rows,
              delimiter
            );
          }
        });

        sqlBtn.addEventListener("click", () => {
          setError("");
          if (key === "accounts") {
            if (state.accounts.rows.length === 0) {
              setError("No parsed accounts. Parse a CSV first.");
              return;
            }
            const result = generateAccountsSql(
              state.accounts.headers,
              state.accounts.rows
            );
            if (result.error) {
              setError(result.error);
              return;
            }
            sqlOutput.value = result.sql;
            return;
          }
          if (key === "movements") {
            if (state.movements.rows.length === 0) {
              setError("No parsed movements. Parse a CSV first.");
              return;
            }
            const result = generateMovementsSql(
              state.movements.headers,
              state.movements.rows
            );
            if (result.error) {
              setError(result.error);
              return;
            }
            sqlOutput.value = result.sql;
          }
          if (key === "categories") {
            if (state.categories.rows.length === 0) {
              setError("No parsed categories. Parse a CSV first.");
              return;
            }
            const result = generateCategoriesSql(
              state.categories.headers,
              state.categories.rows
            );
            if (result.error) {
              setError(result.error);
              return;
            }
            sqlOutput.value = result.sql;
          }
          if (key === "periodicities") {
            if (state.periodicities.rows.length === 0) {
              setError("No parsed periodicities. Parse a CSV first.");
              return;
            }
            const result = generatePeriodicitiesSql(
              state.periodicities.headers,
              state.periodicities.rows
            );
            if (result.error) {
              setError(result.error);
              return;
            }
            sqlOutput.value = result.sql;
          }
        });
      }

      setupImporter("accounts");
      setupImporter("categories");
      setupImporter("periodicities");
      setupImporter("movements");
    </script>
  </body>
</html>
